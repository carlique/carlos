{\rtf1\ansi\ansicpg1252\cocoartf2867
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 .SFNS-Regular;\f1\fnil\fcharset0 HelveticaNeue-Bold;\f2\fnil\fcharset0 .AppleSystemUIFontMonospaced-Regular;
\f3\fswiss\fcharset0 Helvetica;\f4\fnil\fcharset0 .SFNS-Semibold;\f5\froman\fcharset0 TimesNewRomanPSMT;
\f6\fnil\fcharset0 .SFNS-RegularItalic;}
{\colortbl;\red255\green255\blue255;\red14\green14\blue14;}
{\*\expandedcolortbl;;\cssrgb\c6700\c6700\c6700;}
\paperw11900\paperh16840\margl1440\margr1440\vieww16560\viewh10720\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 Yep. This is the exact moment to \'93freeze\'94 responsibilities + public APIs, and force everything else to go through them (even if some are stubs today). Below is a concrete 
\f1\b module contract map
\f0\b0  you can implement as headers + a few 
\f2 \cf2 *_stub.c
\f0 \cf2  files so the build stays clean while we iterate on timer/IRQs/paging.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs34 \cf2 House rules (so spaghetti can\'92t re-grow)
\f0\b0\fs28 \
\pard\tqr\tx260\tx420\li420\fi-420\sl324\slmult1\sb240\partightenfactor0

\f5 \cf2 	1.	
\f1\b Every module has exactly one public header
\f0\b0 : 
\f2 \cf2 carlos/<mod>.h
\f0 \cf2 \
\pard\tqr\tx500\tx660\li660\fi-660\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	Public structs/types + public functions only.\
	\'95	Everything else is 
\f2 \cf2 static
\f0 \cf2  inside 
\f2 \cf2 .c
\f0 \cf2  or in 
\f2 \cf2 internal/*.h
\f0 \cf2  not included by others.\
\pard\tqr\tx260\tx420\li420\fi-420\sl324\slmult1\sb240\partightenfactor0

\f5 \cf2 	2.	
\f1\b Ownership is explicit
\f0\b0 :\
\pard\tqr\tx500\tx660\li660\fi-660\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	Functions returning heap memory: name contains 
\f2 \cf2 _alloc
\f0 \cf2  or documented \'93caller frees with kfree\'94.\
	\'95	Anything taking 
\f2 \cf2 void **out
\f0 \cf2 : on failure must leave 
\f2 \cf2 *out = 0
\f0 \cf2 .\
\pard\tqr\tx260\tx420\li420\fi-420\sl324\slmult1\sb240\partightenfactor0

\f5 \cf2 	3.	
\f1\b No cross-layer \'93helpfulness\'94
\f0\b0 :\
\pard\tqr\tx500\tx660\li660\fi-660\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	Shell doesn\'92t parse masks; 
\f2 \cf2 klog
\f0 \cf2  does.\
	\'95	
\f2 \cf2 exec
\f0 \cf2  doesn\'92t know FAT internals; it uses 
\f2 \cf2 fs_*
\f0 \cf2  API.\
	\'95	
\f2 \cf2 kmem
\f0 \cf2  doesn\'92t call filesystem or exec, ever.\
\pard\tqr\tx260\tx420\li420\fi-420\sl324\slmult1\sb240\partightenfactor0

\f5 \cf2 	4.	
\f1\b Init order is a contract
\f0\b0  (one place, likely 
\f2 \cf2 kernel_main()
\f0 \cf2 ):\
\pard\tqr\tx500\tx660\li660\fi-660\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 klog_init
\f0 \cf2  \uc0\u8594  
\f2 \cf2 pmm_init
\f0 \cf2  \uc0\u8594  
\f2 \cf2 kmem_init
\f0 \cf2  \uc0\u8594  
\f2 \cf2 vmm_init
\f0 \cf2  (stub now) \uc0\u8594  drivers \u8594  fs mount \u8594  shell\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs34 \cf2 Module responsibilities + exact APIs
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 1) klog \'97 logging + panic/assert (already heading this way)
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	printing (UART + optional fb)\
	\'95	log level/mask runtime control\
	\'95	panic/assert\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/klog.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 klog_init()
\f0 \cf2 , 
\f2 \cf2 klog_enable_fb(bi)
\f0 \cf2 \
	\'95	
\f2 \cf2 kprintf/kvprintf/kputc/kputs
\f0 \cf2 \
	\'95	
\f2 \cf2 g_klog_level
\f0 \cf2 , 
\f2 \cf2 g_klog_mask
\f0 \cf2 \
	\'95	
\f2 \cf2 klog_set_level/_mask
\f0 \cf2 , 
\f2 \cf2 klog_set_level_str/_mask_str
\f0 \cf2 , 
\f2 \cf2 klog_print_state/help
\f0 \cf2 \
	\'95	
\f2 \cf2 KPANIC
\f0 \cf2 , 
\f2 \cf2 KASSERT
\f0 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Not implemented
\f0\b0 : none needed right now.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 2) pmm \'97 physical page allocator (phys addresses only)
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	track free physical pages\
	\'95	allocate/free 4KiB pages (phys)\
	\'95	allocate/free contiguous physical ranges (phys)\
	\'95	
\f6\i \cf2 NO mapping, NO heap objects, NO \'93void
\f0\i0 \cf2 \'94 unless via helper wrappers*\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/pmm.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 void pmm_init(const BootInfo *bi);
\f0 \cf2 \
	\'95	
\f2 \cf2 uint64_t pmm_free_count(void);
\f0 \cf2 \
	\'95	
\f2 \cf2 uint64_t pmm_alloc_page_phys(void);
\f0 \cf2 \
	\'95	
\f2 \cf2 void pmm_free_page_phys(uint64_t phys);
\f0 \cf2 \
	\'95	
\f2 \cf2 uint64_t pmm_alloc_contig_pages_phys(uint64_t pages);
\f0 \cf2 \
	\'95	
\f2 \cf2 void pmm_free_contig_pages_phys(uint64_t base_phys, uint64_t pages);
\f0 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Optional convenience
\f0\b0  (fine, but keep clearly \'93convenience\'94):\
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 void* pmm_alloc_page(void);
\f0 \cf2  / 
\f2 \cf2 void pmm_free_page(void*);
\f0 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\li260\sl324\slmult1\pardirnatural\partightenfactor0
\cf2 (implemented using 
\f2 \cf2 phys_to_ptr(ptr_to_phys)
\f0 \cf2 ; but 
\f6\i \cf2 PMM core stays phys
\f0\i0 \cf2 )\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 3) kmem \'97 kernel heap (alloc/free), backed by PMM
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 kmalloc/kfree
\f0 \cf2 \
	\'95	alignment helpers\
	\'95	maybe later: slabs, small frees; but contract stays stable\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/kmem.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 void kmem_init(void);
\f0 \cf2 \
	\'95	
\f2 \cf2 void* kmalloc(size_t size);
\f0 \cf2 \
	\'95	
\f2 \cf2 void  kfree(void *p);
\f0 \cf2 \
	\'95	
\f2 \cf2 void* kmalloc_aligned(size_t size, size_t align);
\f0 \cf2  
\f6\i \cf2 (stub OK today)
\f0\i0 \cf2 \
	\'95	
\f2 \cf2 size_t kmem_usable_size(void *p);
\f0 \cf2  
\f6\i \cf2 (stub OK today, return 0)
\f0\i0 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Current strategy is OK
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	header-before-user-pointer is normal in allocators. It\'92s not \'93strange\'94; it\'92s basically how malloc implementations track size/class.\
	\'95	Your \'93raw + align_up(base)\'94 pattern in 
\f2 \cf2 exec_elf
\f0 \cf2  is also fine as long as 
\f1\b you always free raw
\f0\b0 , not 
\f2 \cf2 base
\f0 \cf2 .\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 4) vmm \'97 virtual memory / paging / mappings (STUB NOW)
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	mapping/unmapping pages\
	\'95	higher-half / identity mapping policy\
	\'95	page table management\
	\'95	later: user mappings\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/vmm.h)
\f0\b0  
\f6\i \cf2 (implement stubs returning -ENOSYS now)
\f0\i0 \cf2 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 int vmm_init(const BootInfo *bi);
\f0 \cf2 \
	\'95	
\f2 \cf2 int vmm_map_page(uint64_t virt, uint64_t phys, uint64_t flags);
\f0 \cf2 \
	\'95	
\f2 \cf2 int vmm_unmap_page(uint64_t virt);
\f0 \cf2 \
	\'95	
\f2 \cf2 int vmm_map_range(uint64_t virt, uint64_t phys, uint64_t pages, uint64_t flags);
\f0 \cf2 \
	\'95	
\f2 \cf2 uint64_t vmm_translate(uint64_t virt);
\f0 \cf2  
\f6\i \cf2 (stub: return 0)
\f0\i0 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 5) irq / idt / isr \'97 interrupts (STUB NOW)
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	IDT install, ISR registration\
	\'95	enabling/disabling IRQ lines (PIC/APIC later)\
	\'95	dispatch table\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/irq.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 void irq_init(void);
\f0 \cf2  
\f6\i \cf2 (stub ok)
\f0\i0 \cf2 \
	\'95	
\f2 \cf2 void irq_enable(void);
\f0 \cf2  / 
\f2 \cf2 void irq_disable(void);
\f0 \cf2 \
	\'95	
\f2 \cf2 int irq_register(int vec, void (*handler)(void*), void *ctx);
\f0 \cf2  
\f6\i \cf2 (stub: -ENOSYS)
\f0\i0 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 6) time \'97 time source + sleep (already exists)
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	monotonic time in ns\
	\'95	sleep (busy wait now, IRQ/timer later)\
	\'95	later: timer interrupt driver hooks\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/time.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 void time_init(void);
\f0 \cf2  
\f6\i \cf2 (stub ok)
\f0\i0 \cf2 \
	\'95	
\f2 \cf2 uint64_t time_now_ns(void);
\f0 \cf2 \
	\'95	
\f2 \cf2 void time_sleep_ms(uint64_t ms);
\f0 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 7) fs \'97 filesystem fa\'e7ade (mount + basic ops)
\f0\b0\fs28 \
\
Right now FAT16 is your boot FS; later you can swap in \'93carlFS\'94 without touching exec/shell.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	mount/unmount\
	\'95	stat / listdir / read file / write file (write can be stub)\
	\'95	path handling stays outside (path module), fs gets normalized root-relative path\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/fs.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 int fs_mount(Fs *out, /* device */);
\f0 \cf2 \
	\'95	
\f2 \cf2 int fs_stat(Fs *fs, const char *path, FsStat *st);
\f0 \cf2 \
	\'95	
\f2 \cf2 int fs_listdir(Fs *fs, const char *path, CarlosDirEnt *ents, uint32_t max);
\f0 \cf2 \
	\'95	
\f2 \cf2 int fs_read_entire(Fs *fs, const char *path, void **out, uint32_t *out_sz);
\f0 \cf2 \
	\'95	
\f2 \cf2 int fs_read(Fs *fs, const char *path, uint32_t off, uint32_t len, void *dst);
\f0 \cf2 \
	\'95	
\f2 \cf2 int fs_write(...)
\f0 \cf2  
\f6\i \cf2 (stub: -ENOSYS)
\f0\i0 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Implementation today
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 fs_*
\f0 \cf2  calls into 
\f2 \cf2 fat16_*
\f0 \cf2  internally.\
	\'95	
\f2 \cf2 exec
\f0 \cf2  uses 
\f2 \cf2 fs_read_entire
\f0 \cf2  only.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 8) fat16 \'97 FAT16 implementation (private-ish)
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	interpreting on-disk FAT16\
	\'95	
\f6\i \cf2 no kmalloc policy decisions
\f0\i0 \cf2  beyond needing scratch buffers; the caller should provide buffers or it should use kmalloc but document it clearly.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/fat16.h)
\f0\b0 \
Keep it minimal; everything else should be inside 
\f2 \cf2 fs_fat16.c
\f0 \cf2 .\
Ideally 
\f2 \cf2 fat16
\f0 \cf2  isn\'92t used by shell/exec directly anymore once 
\f2 \cf2 fs_*
\f0 \cf2  exists.\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 9) exec \'97 loading + running userland
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	load an image (PIE loader)\
	\'95	run image with stack\
	\'95	define ownership: loader allocs image backing \uc0\u8594  runner frees after return\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/exec.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 int exec_elf_load_pie(const void *file, size_t file_sz, ExecImage *out);
\f0 \cf2 \
	\'95	
\f2 \cf2 int exec_run_path(Fs *fs, const char *path, int argc, char **argv, const char *cwd);
\f0 \cf2 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Contract
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 exec_elf_load_pie
\f0 \cf2  must clean up on every failure path (you already started doing that with 
\f2 \cf2 kfree(raw)
\f0 \cf2 ).\
	\'95	
\f2 \cf2 exec_run_path
\f0 \cf2  must always free:\
\pard\tqr\tx500\tx660\li660\fi-660\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	file buffer\
	\'95	stack\
	\'95	image raw backing\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 10) path \'97 path utilities (stop duplicating)
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	sep detection\
	\'95	normalize\
	\'95	join\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/path.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 int path_is_sep(char c);
\f0 \cf2 \
	\'95	
\f2 \cf2 int path_is_abs(const char *p);
\f0 \cf2 \
	\'95	
\f2 \cf2 int path_join(char *out, size_t cap, const char *cwd, const char *arg);
\f0 \cf2 \
	\'95	
\f2 \cf2 int path_normalize_inplace(char *p);
\f0 \cf2 \
\
Then remove the duplicate normalize/join in shell and kapi (or keep local copies only temporarily, but make it a TODO).\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 11) kapi \'97 syscall surface for userland
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	stable ABI 
\f2 \cf2 CarlosApi
\f0 \cf2 \
	\'95	glue to 
\f2 \cf2 fs_*
\f0 \cf2  and kernel services\
	\'95	cwd state for syscalls\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/kapi.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 extern const CarlosApi g_api;
\f0 \cf2 \
	\'95	
\f2 \cf2 void kapi_bind_fs(Fs *fs);
\f0 \cf2 \
	\'95	
\f2 \cf2 void kapi_set_cwd(const char *cwd);
\f0 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs30 \cf2 12) shell \'97 UI only, no policy
\f0\b0\fs28 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Responsible for
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	read line, split args, dispatch\
	\'95	doesn\'92t parse complex things (delegate to module helpers)\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f1\b \cf2 Public API (carlos/shell.h)
\f0\b0 \
\pard\tqr\tx100\tx260\li260\fi-260\sl324\slmult1\sb240\partightenfactor0
\cf2 	\'95	
\f2 \cf2 void shell_run(const BootInfo *bi, Fs *fs);
\f0 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f3\fs24 \cf0 \
\uc0\u11835 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl324\slmult1\pardirnatural\partightenfactor0

\f4\b\fs34 \cf2 What to do next (cleanup steps)
\f0\b0\fs28 \
\pard\tqr\tx260\tx420\li420\fi-420\sl324\slmult1\sb240\partightenfactor0

\f5 \cf2 	1.	
\f1\b Introduce fs_* fa\'e7ade
\f0\b0  and stop calling 
\f2 \cf2 fat16_*
\f0 \cf2  from 
\f2 \cf2 exec.c
\f0 \cf2  and shell.\

\f5 	2.	Move all path join/normalize to 
\f2 \cf2 path.*
\f0 \cf2  and delete duplicates.\

\f5 	3.	Make 
\f2 \cf2 *_stub.c
\f0 \cf2  for 
\f2 \cf2 vmm
\f0 \cf2 , 
\f2 \cf2 irq
\f0 \cf2  so APIs exist now and compile clean.\

\f5 	4.	Create a small \'93contracts\'94 doc (even a 
\f2 \cf2 Kernel/docs/contracts.md
\f0 \cf2 ) listing exactly the above.\
\
If you want, paste your current 
\f2 \cf2 carlos/*.h
\f0 \cf2  list (or just the top-level include tree), and I\'92ll propose the 
\f1\b exact headers + where each function should live
\f0\b0  so you can refactor without breaking the build.}